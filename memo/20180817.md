
- 返却地として、ok err のどちらを返すかをどのように考えるか？
    - bool(ok)を返すか errorを返すかの2パターンがあり、単純に成功か失敗かを返すだけでいいならばbool・付加情報(どのようなerrorか)を返却した方がいい場合にはerrorを返すようにする
- complex64は基本的には使わないような想定なのか？
    - golangに限らず、今の時代ではfloat32のような節約した物を使うことはあまりない。特に計算パッケージとしては制度がおちるcomplex64は用意しなくていいと考えたのだろう。
- 生文字列ではキャリッジリターンを削除するというのはどういうことか？
    - osごとにファイルの最後につけられる改行コードが異なるようなものを吸収するwindowsでは最後にキャリッジリターンがありunix系ではない、それによって文字列比較が通らないみたいなものをなくす
- bytes.Bufferで値をバッファいる間は、メモリをどのように確保するのでしょうか？
    - ソースコード読めばわかるよ。bytes.Bufferはスライスを用いて実装されていて、最初に64バイト保持し、入らなくなったタイミングで2倍にする。
- 「コンパイラは，型に結びついていない定数を基本系の値よりもはるかに高い精度で表現します．(略) 少なくとも256ビットの精度を想定して構いません．」とあるが，なぜ，高い精度で表現する必要があったのか?
    - よくわからない。もしかしたら数値計算をがっつりするときにはこの精度が役に立つのかもしれない
- テストでスライスの要素の等価性を調べるために reflect.DeepEquals を使っていたのですが、ここで言及されているように、equalを定義してチェックすべきなのでしょうか？(テキストではmapを比較するためのequalを実装している)
    - DeepEquals をテストで使う分には問題ないが、挙動的に自分の想定と異なる場合が存在する([]byte{} != []byte{nil}) ので実装に利用するには注意して利用する必要がある
- 


- Javaではnullを返すとチェックしないといけないので空のmapを返すようなことが慣習だが、goではnilを返す慣習なのでok
- Javaでは == は数値か参照のポインタが同じところを指しているかのみが比較できる
- goではかなりの者に対して == が定義されている
- 複数の値を代入できるためtmp変数を利用することなく1行でswapできる
Java: 
    tmp = x
    x = y
    y = tmp
Go: 
    x, y = y, x


- パラメーターとして何が指定できるかをhelpと打つとでてくるようにすると嬉しい