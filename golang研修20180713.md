# golang 研修

## 質問回答

- 変数宣言が 4 種類あるのはなぜか
  - 正直理由はわからない。本に書いている通りに使おう
- 明示的な初期化無しで文字列を連結に使用しているが、これは実際には明示的な初期化を行ったほうが良いのか
  - go ではゼロ値が決まっているのでそれを理解して行えば明示的な初期化は必要ない
- p make 関数で領域を確保したときに領域数が指定されていないが、これは不足時に追加されるということでいいのか？
  - 構文的には指定できるが、そもそも map はメモリを犠牲にして O(1)を実現するもので、bucket(ハッシュテーブル)の大きさを可変にしないといけないため、map 自体の大きさを指定することに意味は無い
- p 型が違うものに対して同じ range を利用できるのはなぜか
  - 実際は型によって range の振る舞いが違う
- \_ は繰り返し利用しても怒られないの？
  - \_ は変数では無いので繰り返し使っても怒られない
- なぜ事前宣言と予約語に分けられているのか
  - わからない
- go に assert がないのは？
  - go のテストを書くのにまた別のことを勉強しないといけないということを避けたい
  - assert では結局出力では何かわからないのでなしにしてる
- init 関数が複数あるのはなぜ？
  - init を意味のある単位で分けたい場合 + わざわざ関数定義をしたくない場合
    - あまり使用されない
  - パッケージの import 時にそのパッケージの init 関数は呼ばれる
    - つまり, import \_ "hoge" のようなものは利用しないが init 関数を呼びたい場合に使用
- go が近年サーバーサイドで採用されてきた理由は？
  - 1 秒間にさばかないといけないリクエストが増え、軽量であることが求められる
  - 軽量で動作(goroutine)
    - スケジューリングを go のランタイムで行っている
  - デプロイが楽
  - クロスコンパイルが楽

## その他の話

- プログラミング一般
  - 標準ライブラリがあるものは標準ライブラリを使う(あたりまえ)
  - system call を発行すると os スレッドがたてられる
  - O(1)はどのように実現している？
    - ハッシュ値を計算したときに一意に特定されることが条件
    - しかし、bucket に保持できる要素数は決まっているのでそこにマッピングしないといけない
    - Java などでは linklist を作成することで衝突に対処している
    - ただ要素が溢れた場合再マッピングし直す
  - NaN は自分自身と比較しても false となる
    - つまり、自分自身と比較することで NaN かどうか判定できる
- go 一般
  - go では web 系が簡単に書ける
  - インポートはディレクトリのパスを指定しているだけで、その中のパッケージ名はファイルの中まで見ないとわからないので異なるパッケージ名が存在すればインポートのディレクトリ名と呼び出し時の名前が異なる(そのため、ディレクトリ名とパッケージ名は一致させるのが通例)
  - 大文字、小文字の概念がない言語(日本語とか)で書くと公開されてしまう
  - 空の構造体などは変更をする手段がないため実態が 1 つでも良いので同じアドレスを指す場合もある
    - 空の構造体はよく利用する
    - 不変のものは 1 つあれば十分
      - コンパイラは面倒見てくれないので自分で考えて書かないといけない
  - コンストラクターは存在しない
  - 明示的な初期化が必ず必要な場合には new 関数を用いて生成するのが一般的
  - go ではセミコロンはコンパイラが勝手に挿入してくれる
  - (string error) で error を返却する時、string 型に nil が存在しないので、空文字""を返すのが一般的
  - 通常スタックサイズは固定 2MB に対して、go は 10kB 程度から始まって可変で最大 1GB 程度まで広がる
    - これによってスタックが軽くなり並列処理が早くなる
    - スタックは広がるたびにアドレス空間が変更される
  - package の長い説明を書きたいときは doc.go に書くのが慣例
- 定数について
  - const は定数宣言
  - go では定数は 256 ビットを保証している
  - コンパイル時に定数を計算している(コンパイラが行っている)
  - 定数は言語仕様上型を持っていない
- ベンチマークについて
  - testing.b.N は徐々に増やしながら意味のある値を取れるまで回してくれる
  - ベンチマークで標準偏差も欲しいのでは？
    - とりあえずここではできない
    - データを乱数で生成した場合などではベンチマークの値は意味を成さないことがある
    - 関数に入れる値によってベンチマークの値が変わる(あたりまえ)
  - ベンチマークを測るときに変更が何も影響を及ぼさないようなものであれば最適化されてきちんと呼ばれなくなることがある
    - 0.4ns とかになってくると最適化(SSA)されて呼ばれていない事がほとんど
    - 副作用のない関数で返却値を利用していない場合，いみのない関数呼び出しと判断して関数呼び出し自体が消える
    - 正確にベンチマークを取ろうとすると、明示的に副作用のあるように書く必要がある(ほんと？)
    - 静的な計算はコンパイラがやっちゃう

## 次の注意点

- ch3/ex8 big.Rat は計算量を考慮しないと計算が終わらない
- ch4/ex4 中間バッファ少ない量でできるだけ 1 回で rotate する
- ch4/ex11 github の api を理解してやってね
- ch4/ex13 現在では、お金払わないとできないのでしなくて ok
